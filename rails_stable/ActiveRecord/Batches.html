<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Module: ActiveRecord::Batches &mdash; Rails-5-1-stable</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />
<link rel='stylesheet'  type='text/css' href='../../css/custom.css' />
<link rel='stylesheet'  type='text/css' href='../../css/common.css' />

<script type='text/javascript'>
  var pathId = "ActiveRecord::Batches",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
        <a href='../../index.html'>Home</a> &raquo; 
        <a href='../index.html'>Rails-5-1-stable</a> &raquo; 
        <a href='../_index.html#alpha_B'>Index (B)</a> &raquo; 
        <a href="../ActiveRecord.html" title="ActiveRecord (module)">ActiveRecord</a> &raquo; 
        <span class='title'><a id='t2_doc_top' href='#'>Batches&nbsp;&#x25B2;</a></span>
      </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='module'>
<h1>Module: ActiveRecord::Batches</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="Batches/BatchEnumerator.html" title="ActiveRecord::Batches::BatchEnumerator (class)">BatchEnumerator</a>      </div>
    </td></tr>
    <tr><td class='box_h' colspan='2'>Extension / Inclusion / Inheritance Descendants</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Included In:</div>
      <div class='box_11'>
        <a href="AssociationRelation.html" title="ActiveRecord::AssociationRelation (class)">AssociationRelation</a>,
          <a href="Associations/CollectionProxy.html" title="ActiveRecord::Associations::CollectionProxy (class)">Associations::CollectionProxy</a>,
          <a href="Relation.html" title="ActiveRecord::Relation (class)">Relation</a>
      </div>
    </td></tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches.rb#L4'>activerecord/lib/active_record/relation/batches.rb</a><span class='defines'>,<br /><a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches/batch_enumerator.rb#L2'>activerecord/lib/active_record/relation/batches/batch_enumerator.rb</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='ORDER_IGNORE_MESSAGE-constant' class='summary_signature'>ORDER_IGNORE_MESSAGE =</span>
    <br/>
    <a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches.rb#L5-L5'># File 'activerecord/lib/active_record/relation/batches.rb', line 5</a>    <pre class='code ruby'><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Scoped order is ignored, it&#39;s forced to be batch order.</span><span class='tstring_end'>&quot;</span></span></pre>
  </li>
</ul>
</div>
        

<h2 class='h2_sum' id='instance_Method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#find_each-instance_method" title="#find_each (instance method)">#<strong>find_each</strong>(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Looping through a collection of records from the database (using the
<a href="Scoping/Named/ClassMethods.html#all-instance_method" title="ActiveRecord::Scoping::Named::ClassMethods#all (method)">Scoping::Named::ClassMethods#all</a> method, for example) is very inefficient
since it will try to instantiate all the objects at once.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#find_in_batches-instance_method" title="#find_in_batches (instance method)">#<strong>find_in_batches</strong>(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Yields each batch of records that was found by the find options as an
array.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#in_batches-instance_method" title="#in_batches (instance method)">#<strong>in_batches</strong>(of: 1000, start: nil, finish: nil, load: false, error_on_ignore: nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Yields <a href="Relation.html" title="ActiveRecord::Relation (class)">Relation</a> objects to work with a batch of records.</p></div>
    </div>
  </li>
</ul>
</div>
<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="find_each-instance_method">
  <h3 class='signature  first'>
    #<strong>find_each</strong>(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Looping through a collection of records from the database (using the
<a href="Scoping/Named/ClassMethods.html#all-instance_method" title="ActiveRecord::Scoping::Named::ClassMethods#all (method)">Scoping::Named::ClassMethods#all</a> method, for example) is very inefficient
since it will try to instantiate all the objects at once.</p>

<p>In that case, batch processing methods allow you to work with the records
in batches, thereby greatly reducing memory consumption.</p>

<p>The <code>#find_each</code> method uses <a href="#find_in_batches-instance_method" title="ActiveRecord::Batches#find_in_batches (method)">#find_in_batches</a> with a batch size of 1000
(or as specified by the <code>:batch_size</code> option).</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_find_each'>find_each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span>
  <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_do_awesome_stuff'>do_awesome_stuff</span>
<span class='kw'>end</span>

<span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>age &gt; 21</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_find_each'>find_each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span>
  <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span>
<span class='kw'>end</span></code></pre>

<p>If you do not provide a block to <code>#find_each</code>, it will return an Enumerator
for chaining with other methods:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_find_each'>find_each</span><span class='period'>.</span><span class='id identifier rubyid_with_index'>with_index</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='comma'>,</span> <span class='id identifier rubyid_index'>index</span><span class='op'>|</span>
  <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_award_trophy'>award_trophy</span><span class='lparen'>(</span><span class='id identifier rubyid_index'>index</span> <span class='op'>+</span> <span class='int'>1</span><span class='rparen'>)</span>
<span class='kw'>end</span></code></pre>

<h4 id="label-Options">Options</h4>
<ul><li>
<p><code>:batch_size</code> - Specifies the size of the batch. Default to
1000.</p>
</li><li>
<p><code>:start</code> - Specifies the primary key value to start from,
inclusive of the value.</p>
</li><li>
<p><code>:finish</code> - Specifies the primary key value to end at, inclusive
of the value.</p>
</li><li>
<p><code>:error_on_ignore</code> - Overrides the application config to specify
if an error should be raised when</p>

<pre class="code ruby"><code class="ruby">an order is present in the relation.</code></pre>
</li></ul>

<p>Limits are honored, and if present there is no requirement for the batch
size, it can be less than, equal, or greater than the limit.</p>

<p>The options <code>start</code> and <code>finish</code> are especially useful if you want multiple
workers dealing with the same processing queue. You can make worker 1
handle all the records between id 1 and 9999 and worker 2 handle from 10000
and beyond by setting the <code>:start</code> and <code>:finish</code>
option on each worker.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Let&#39;s process from record 10_000 on.
</span><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_find_each'>find_each</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='int'>10_000</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span>
  <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span>
<span class='kw'>end</span></code></pre>

<p>NOTE: It&#39;s not possible to set the order. That is automatically set to
ascending on the primary key ("id ASC") to make the batch ordering work.
This also means that this method only works when the primary key is
orderable (e.g. an integer or string).</p>

<p>NOTE: By its nature, batch processing is subject to race conditions if
other processes are modifying the database.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches.rb#L60-L71'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num'>


60
61
62
63
64
65
66
67
68
69
70
71</pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'activerecord/lib/active_record/relation/batches.rb', line 60</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_find_each'>find_each</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>batch_size:</span> <span class='int'>1000</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
    <span class='id identifier rubyid_find_in_batches'>find_in_batches</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='id identifier rubyid_finish'>finish</span><span class='comma'>,</span> <span class='label'>batch_size:</span> <span class='id identifier rubyid_batch_size'>batch_size</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='id identifier rubyid_error_on_ignore'>error_on_ignore</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_records'>records</span><span class='op'>|</span>
      <span class='id identifier rubyid_records'>records</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_record'>record</span><span class='op'>|</span> <span class='kw'>yield</span> <span class='id identifier rubyid_record'>record</span> <span class='rbrace'>}</span>
    <span class='kw'>end</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_enum_for'>enum_for</span><span class='lparen'>(</span><span class='symbeg'>:</span><span class='id identifier rubyid_find_each'>find_each</span><span class='comma'>,</span> <span class='label'>start:</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='id identifier rubyid_finish'>finish</span><span class='comma'>,</span> <span class='label'>batch_size:</span> <span class='id identifier rubyid_batch_size'>batch_size</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='id identifier rubyid_error_on_ignore'>error_on_ignore</span><span class='rparen'>)</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='kw'>self</span>
      <span class='id identifier rubyid_apply_limits'>apply_limits</span><span class='lparen'>(</span><span class='id identifier rubyid_relation'>relation</span><span class='comma'>,</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='id identifier rubyid_finish'>finish</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="find_in_batches-instance_method">
  <h3 class='signature '>
    #<strong>find_in_batches</strong>(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Yields each batch of records that was found by the find options as an
array.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>age &gt; 21</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_find_in_batches'>find_in_batches</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_group'>group</span><span class='op'>|</span>
  <span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='int'>50</span><span class='rparen'>)</span> <span class='comment'># Make sure it doesn&#39;t get too crowded in there!
</span>  <span class='id identifier rubyid_group'>group</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></code></pre>

<p>If you do not provide a block to <code>#find_in_batches</code>, it will return an
Enumerator for chaining with other methods:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_find_in_batches'>find_in_batches</span><span class='period'>.</span><span class='id identifier rubyid_with_index'>with_index</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_group'>group</span><span class='comma'>,</span> <span class='id identifier rubyid_batch'>batch</span><span class='op'>|</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Processing group #</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_batch'>batch</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_group'>group</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_recover_from_last_night!'>recover_from_last_night!</span><span class='rparen'>)</span>
<span class='kw'>end</span></code></pre>

<p>To be yielded each record one by one, use <a href="#find_each-instance_method" title="ActiveRecord::Batches#find_each (method)">#find_each</a> instead.</p>

<h4 id="label-Options">Options</h4>
<ul><li>
<p><code>:batch_size</code> - Specifies the size of the batch. Default to
1000.</p>
</li><li>
<p><code>:start</code> - Specifies the primary key value to start from,
inclusive of the value.</p>
</li><li>
<p><code>:finish</code> - Specifies the primary key value to end at, inclusive
of the value.</p>
</li><li>
<p><code>:error_on_ignore</code> - Overrides the application config to specify
if an error should be raised when</p>

<pre class="code ruby"><code class="ruby">an order is present in the relation.</code></pre>
</li></ul>

<p>Limits are honored, and if present there is no requirement for the batch
size, it can be less than, equal, or greater than the limit.</p>

<p>The options <code>start</code> and <code>finish</code> are especially useful if you want multiple
workers dealing with the same processing queue. You can make worker 1
handle all the records between id 1 and 9999 and worker 2 handle from 10000
and beyond by setting the <code>:start</code> and <code>:finish</code>
option on each worker.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Let&#39;s process from record 10_000 on.
</span><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_find_in_batches'>find_in_batches</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='int'>10_000</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_group'>group</span><span class='op'>|</span>
  <span class='id identifier rubyid_group'>group</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></code></pre>

<p>NOTE: It&#39;s not possible to set the order. That is automatically set to
ascending on the primary key ("id ASC") to make the batch ordering work.
This also means that this method only works when the primary key is
orderable (e.g. an integer or string).</p>

<p>NOTE: By its nature, batch processing is subject to race conditions if
other processes are modifying the database.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches.rb#L119-L131'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num'>


119
120
121
122
123
124
125
126
127
128
129
130
131</pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'activerecord/lib/active_record/relation/batches.rb', line 119</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_find_in_batches'>find_in_batches</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>batch_size:</span> <span class='int'>1000</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='kw'>self</span>
  <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_to_enum'>to_enum</span><span class='lparen'>(</span><span class='symbeg'>:</span><span class='id identifier rubyid_find_in_batches'>find_in_batches</span><span class='comma'>,</span> <span class='label'>start:</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='id identifier rubyid_finish'>finish</span><span class='comma'>,</span> <span class='label'>batch_size:</span> <span class='id identifier rubyid_batch_size'>batch_size</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='id identifier rubyid_error_on_ignore'>error_on_ignore</span><span class='rparen'>)</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_total'>total</span> <span class='op'>=</span> <span class='id identifier rubyid_apply_limits'>apply_limits</span><span class='lparen'>(</span><span class='id identifier rubyid_relation'>relation</span><span class='comma'>,</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='id identifier rubyid_finish'>finish</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span>
      <span class='lparen'>(</span><span class='id identifier rubyid_total'>total</span> <span class='op'>-</span> <span class='int'>1</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_div'>div</span><span class='lparen'>(</span><span class='id identifier rubyid_batch_size'>batch_size</span><span class='rparen'>)</span> <span class='op'>+</span> <span class='int'>1</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_in_batches'>in_batches</span><span class='lparen'>(</span><span class='label'>of:</span> <span class='id identifier rubyid_batch_size'>batch_size</span><span class='comma'>,</span> <span class='label'>start:</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='id identifier rubyid_finish'>finish</span><span class='comma'>,</span> <span class='label'>load:</span> <span class='kw'>true</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='id identifier rubyid_error_on_ignore'>error_on_ignore</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_batch'>batch</span><span class='op'>|</span>
    <span class='kw'>yield</span> <span class='id identifier rubyid_batch'>batch</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="in_batches-instance_method">
  <h3 class='signature '>
    #<strong>in_batches</strong>(of: 1000, start: nil, finish: nil, load: false, error_on_ignore: nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Yields <a href="Relation.html" title="ActiveRecord::Relation (class)">Relation</a> objects to work with a batch of records.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>age &gt; 21</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_relation'>relation</span><span class='op'>|</span>
  <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_delete_all'>delete_all</span>
  <span class='id identifier rubyid_sleep'>sleep</span><span class='lparen'>(</span><span class='int'>10</span><span class='rparen'>)</span> <span class='comment'># Throttle the delete queries
</span><span class='kw'>end</span></code></pre>

<p>If you do not provide a block to <code>#in_batches</code>, it will return a
<a href="Batches/BatchEnumerator.html" title="ActiveRecord::Batches::BatchEnumerator (class)">Batches::BatchEnumerator</a> which is enumerable.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_with_index'>with_index</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_relation'>relation</span><span class='comma'>,</span> <span class='id identifier rubyid_batch_index'>batch_index</span><span class='op'>|</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Processing relation #</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_batch_index'>batch_index</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_relation'>relation</span><span class='op'>|</span> <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_delete_all'>delete_all</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></code></pre>

<p>Examples of calling methods on the returned
<a href="Batches/BatchEnumerator.html" title="ActiveRecord::Batches::BatchEnumerator (class)">Batches::BatchEnumerator</a> object:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_delete_all'>delete_all</span>
<span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_update_all'>update_all</span><span class='lparen'>(</span><span class='label'>awesome:</span> <span class='kw'>true</span><span class='rparen'>)</span>
<span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_each_record'>each_record</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span><span class='rparen'>)</span></code></pre>

<h4 id="label-Options">Options</h4>
<ul><li>
<p><code>:of</code> - Specifies the size of the batch. Default to 1000.</p>
</li><li>
<p><code>:load</code> - Specifies if the relation should be loaded. Default to
false.</p>
</li><li>
<p><code>:start</code> - Specifies the primary key value to start from,
inclusive of the value.</p>
</li><li>
<p><code>:finish</code> - Specifies the primary key value to end at, inclusive
of the value.</p>
</li><li>
<p><code>:error_on_ignore</code> - Overrides the application config to specify
if an error should be raised when</p>

<pre class="code ruby"><code class="ruby">an order is present in the relation.</code></pre>
</li></ul>

<p>Limits are honored, and if present there is no requirement for the batch
size, it can be less than, equal, or greater than the limit.</p>

<p>The options <code>start</code> and <code>finish</code> are especially useful if you want multiple
workers dealing with the same processing queue. You can make worker 1
handle all the records between id 1 and 9999 and worker 2 handle from 10000
and beyond by setting the <code>:start</code> and <code>:finish</code>
option on each worker.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Let&#39;s process from record 10_000 on.
</span><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='lparen'>(</span><span class='label'>start:</span> <span class='int'>10_000</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_update_all'>update_all</span><span class='lparen'>(</span><span class='label'>awesome:</span> <span class='kw'>true</span><span class='rparen'>)</span></code></pre>

<p>An example of calling where query method on the relation:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_relation'>relation</span><span class='op'>|</span>
  <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_update_all'>update_all</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>age = age + 1</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>age &gt; 21</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_update_all'>update_all</span><span class='lparen'>(</span><span class='label'>should_party:</span> <span class='kw'>true</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>age &lt;= 21</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_delete_all'>delete_all</span>
<span class='kw'>end</span></code></pre>

<p>NOTE: If you are going to iterate through each record, you should call
<code>#each_record</code> on the yielded BatchEnumerator:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_in_batches'>in_batches</span><span class='period'>.</span><span class='id identifier rubyid_each_record'>each_record</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_party_all_night!'>party_all_night!</span><span class='rparen'>)</span></code></pre>

<p>NOTE: It&#39;s not possible to set the order. That is automatically set to
ascending on the primary key ("id ASC") to make the batch ordering
consistent. Therefore the primary key must be orderable, e.g an integer or
a string.</p>

<p>NOTE: By its nature, batch processing is subject to race conditions if
other processes are modifying the database.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/rails/rails/blob/5-1-stable/activerecord/lib/active_record/relation/batches.rb#L194-L248'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num'>


194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248</pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'activerecord/lib/active_record/relation/batches.rb', line 194</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_in_batches'>in_batches</span><span class='lparen'>(</span><span class='label'>of:</span> <span class='int'>1000</span><span class='comma'>,</span> <span class='label'>start:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>load:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>error_on_ignore:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='kw'>self</span>
  <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
    <span class='kw'>return</span> <span class='const'><a href="Batches/BatchEnumerator.html" title="ActiveRecord::Batches::BatchEnumerator (class)">BatchEnumerator</a></span><span class='period'>.</span><span class='id identifier rubyid_new'><a href="Batches/BatchEnumerator.html#new-class_method" title="ActiveRecord::Batches::BatchEnumerator.new (method)">new</a></span><span class='lparen'>(</span><span class='label'>of:</span> <span class='id identifier rubyid_of'>of</span><span class='comma'>,</span> <span class='label'>start:</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='label'>finish:</span> <span class='id identifier rubyid_finish'>finish</span><span class='comma'>,</span> <span class='label'>relation:</span> <span class='kw'>self</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>if</span> <span class='id identifier rubyid_arel'>arel</span><span class='period'>.</span><span class='id identifier rubyid_orders'>orders</span><span class='period'>.</span><span class='id identifier rubyid_present?'>present?</span>
    <span class='id identifier rubyid_act_on_ignored_order'>act_on_ignored_order</span><span class='lparen'>(</span><span class='id identifier rubyid_error_on_ignore'>error_on_ignore</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_batch_limit'>batch_limit</span> <span class='op'>=</span> <span class='id identifier rubyid_of'>of</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_limit_value'>limit_value</span>
    <span class='id identifier rubyid_remaining'>remaining</span>   <span class='op'>=</span> <span class='id identifier rubyid_limit_value'>limit_value</span>
    <span class='id identifier rubyid_batch_limit'>batch_limit</span> <span class='op'>=</span> <span class='id identifier rubyid_remaining'>remaining</span> <span class='kw'>if</span> <span class='id identifier rubyid_remaining'>remaining</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_batch_limit'>batch_limit</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_reorder'>reorder</span><span class='lparen'>(</span><span class='id identifier rubyid_batch_order'>batch_order</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='id identifier rubyid_batch_limit'>batch_limit</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='id identifier rubyid_apply_limits'>apply_limits</span><span class='lparen'>(</span><span class='id identifier rubyid_relation'>relation</span><span class='comma'>,</span> <span class='id identifier rubyid_start'>start</span><span class='comma'>,</span> <span class='id identifier rubyid_finish'>finish</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_batch_relation'>batch_relation</span> <span class='op'>=</span> <span class='id identifier rubyid_relation'>relation</span>

  <span class='id identifier rubyid_loop'>loop</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_load'>load</span>
      <span class='id identifier rubyid_records'>records</span> <span class='op'>=</span> <span class='id identifier rubyid_batch_relation'>batch_relation</span><span class='period'>.</span><span class='id identifier rubyid_records'>records</span>
      <span class='id identifier rubyid_ids'>ids</span> <span class='op'>=</span> <span class='id identifier rubyid_records'>records</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_yielded_relation'>yielded_relation</span> <span class='op'>=</span> <span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='id identifier rubyid_primary_key'>primary_key</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_ids'>ids</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_yielded_relation'>yielded_relation</span><span class='period'>.</span><span class='id identifier rubyid_load_records'>load_records</span><span class='lparen'>(</span><span class='id identifier rubyid_records'>records</span><span class='rparen'>)</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_ids'>ids</span> <span class='op'>=</span> <span class='id identifier rubyid_batch_relation'>batch_relation</span><span class='period'>.</span><span class='id identifier rubyid_pluck'>pluck</span><span class='lparen'>(</span><span class='id identifier rubyid_primary_key'>primary_key</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_yielded_relation'>yielded_relation</span> <span class='op'>=</span> <span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='id identifier rubyid_primary_key'>primary_key</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_ids'>ids</span><span class='rparen'>)</span>
    <span class='kw'>end</span>

    <span class='kw'>break</span> <span class='kw'>if</span> <span class='id identifier rubyid_ids'>ids</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>

    <span class='id identifier rubyid_primary_key_offset'>primary_key_offset</span> <span class='op'>=</span> <span class='id identifier rubyid_ids'>ids</span><span class='period'>.</span><span class='id identifier rubyid_last'>last</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Primary key not included in the custom select clause</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='id identifier rubyid_primary_key_offset'>primary_key_offset</span>

    <span class='kw'>yield</span> <span class='id identifier rubyid_yielded_relation'>yielded_relation</span>

    <span class='kw'>break</span> <span class='kw'>if</span> <span class='id identifier rubyid_ids'>ids</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_batch_limit'>batch_limit</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_limit_value'>limit_value</span>
      <span class='id identifier rubyid_remaining'>remaining</span> <span class='op'>-=</span> <span class='id identifier rubyid_ids'>ids</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span>

      <span class='kw'>if</span> <span class='id identifier rubyid_remaining'>remaining</span> <span class='op'>==</span> <span class='int'>0</span>
        <span class='comment'># Saves a useless iteration when the limit is a multiple of the
</span>        <span class='comment'># batch size.
</span>        <span class='kw'>break</span>
      <span class='kw'>elsif</span> <span class='id identifier rubyid_remaining'>remaining</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_batch_limit'>batch_limit</span>
        <span class='id identifier rubyid_relation'>relation</span> <span class='op'>=</span> <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='id identifier rubyid_remaining'>remaining</span><span class='rparen'>)</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_batch_relation'>batch_relation</span> <span class='op'>=</span> <span class='id identifier rubyid_relation'>relation</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='id identifier rubyid_arel_attribute'>arel_attribute</span><span class='lparen'>(</span><span class='id identifier rubyid_primary_key'>primary_key</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_gt'>gt</span><span class='lparen'>(</span><span class='id identifier rubyid_primary_key_offset'>primary_key_offset</span><span class='rparen'>)</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'>
  Generated by
  <a href='http://yardoc.org' title='Yay! A Ruby Documentation Tool' target="_parent">yard</a>
  0.9.8 with <a href='https://msp-greg.github.io/yard-t2/' title='yard-t2' target="_parent">yard-t2</a> 0.9.0 (ruby-2.5.0p-1)
</div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>